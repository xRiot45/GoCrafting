package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// {{.StructName}}Handler handles HTTP requests for {{.StructName}} resources.
// It uses the standard library "net/http" with Go 1.22+ routing patterns.
type {{.StructName}}Handler struct {
	// For Small Scale projects, you can inject the Database instance directly.
	// Example: db *sql.DB or db *gorm.DB
	// Or leave it empty if you use a global DB variable.
}

// New{{.StructName}}Handler creates a new instance of {{.StructName}}Handler.
func New{{.StructName}}Handler() *{{.StructName}}Handler {
	return &{{.StructName}}Handler{}
}

// RegisterRoutes registers the API endpoints for this handler to the provided ServeMux.
// It utilizes Go 1.22+ routing patterns (Method + Path + Wildcards).
//
// Usage in main.go:
//   mux := http.NewServeMux()
//   handler := handlers.New{{.StructName}}Handler()
//   handler.RegisterRoutes(mux)
func (h *{{.StructName}}Handler) RegisterRoutes(mux *http.ServeMux) {
	// Since net/http doesn't have built-in grouping like Gin/Fiber,
	// we define a base path prefix manually.
	basePath := "/{{.StructName}}"

	// Register patterns: [METHOD] [PATH]
	mux.HandleFunc("POST "+basePath, h.Create)
	mux.HandleFunc("GET "+basePath, h.FindAll)
	mux.HandleFunc("GET "+basePath+"/{id}", h.FindOne)
	mux.HandleFunc("PUT "+basePath+"/{id}", h.Update)
	mux.HandleFunc("DELETE "+basePath+"/{id}", h.Delete)
}

// Create handles the creation of a new {{.StructName}}.
// POST /{{.StructName}}
func (h *{{.StructName}}Handler) Create(w http.ResponseWriter, r *http.Request) {
	// 1. Define Request Struct (DTO)
	type CreateRequest struct {
		Name string `json:"name"`
		// Add other fields and validation logic here
	}

	var req CreateRequest

	// 2. Decode JSON Body
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid request body: "+err.Error())
		return
	}

	// 3. Database Logic (TODO)
	// Example: _, err := h.db.Exec("INSERT INTO ...", req.Name)

	// 4. Return Response
	response := map[string]interface{}{
		"message": "{{.StructName}} created successfully",
		"data":    req,
	}
	h.writeJSON(w, http.StatusCreated, response)
}

// FindAll retrieves a list of {{.StructName}}.
// GET /{{.StructName}}
func (h *{{.StructName}}Handler) FindAll(w http.ResponseWriter, r *http.Request) {
	// TODO: Fetch data from the database
	
	mockData := []map[string]interface{}{
		{"id": "1", "name": "Sample {{.StructName}} 1"},
		{"id": "2", "name": "Sample {{.StructName}} 2"},
	}

	h.writeJSON(w, http.StatusOK, map[string]interface{}{
		"data": mockData,
	})
}

// FindOne retrieves a single {{.StructName}} by ID.
// GET /{{.StructName}}/{id}
func (h *{{.StructName}}Handler) FindOne(w http.ResponseWriter, r *http.Request) {
	// Get path value using Go 1.22 feature
	id := r.PathValue("id")

	// TODO: Fetch single item by ID from database

	h.writeJSON(w, http.StatusOK, map[string]interface{}{
		"message": "Detail of {{.StructName}}",
		"id":      id,
	})
}

// Update modifies an existing {{.StructName}}.
// PUT /{{.StructName}}/{id}
func (h *{{.StructName}}Handler) Update(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")

	var req map[string]interface{}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid request body")
		return
	}

	// TODO: Execute update query in database

	h.writeJSON(w, http.StatusOK, map[string]interface{}{
		"message": "{{.StructName}} updated successfully",
		"id":      id,
		"changes": req,
	})
}

// Delete removes a {{.StructName}}.
// DELETE /{{.StructName}}/{id}
func (h *{{.StructName}}Handler) Delete(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")

	// TODO: Execute delete query in database

	h.writeJSON(w, http.StatusOK, map[string]interface{}{
		"message": "{{.StructName}} deleted successfully",
		"id":      id,
	})
}

// ---------------------------------------------------------------------
// Helper Functions (Private)
// ---------------------------------------------------------------------

// writeJSON writes a JSON response with the given status code and proper headers.
func (h *{{.StructName}}Handler) writeJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if err := json.NewEncoder(w).Encode(data); err != nil {
		// Log error to console if encoding fails
		fmt.Printf("Error encoding JSON: %v\n", err)
	}
}

// writeError writes a structured JSON error response.
func (h *{{.StructName}}Handler) writeError(w http.ResponseWriter, status int, message string) {
	h.writeJSON(w, status, map[string]string{"error": message})
}